package config

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"dhf-config-manager/internal/models"
	"gopkg.in/yaml.v3"
)

type Parser struct {
	schema *models.Schema
}

func NewParser() *Parser {
	return &Parser{}
}

func (p *Parser) LoadSchema(filePath string) error {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("failed to read schema file: %w", err)
	}

	var schema models.Schema
	if err := yaml.Unmarshal(data, &schema); err != nil {
		return fmt.Errorf("failed to parse schema: %w", err)
	}

	p.schema = &schema
	return nil
}

func (p *Parser) GetSchema() *models.Schema {
	return p.schema
}

func (p *Parser) LoadUserConfig(filePath string) (*models.UserConfig, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return &models.UserConfig{Values: make(map[string]interface{})}, nil
	}

	var config models.UserConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse user config: %w", err)
	}

	if config.Values == nil {
		config.Values = make(map[string]interface{})
	}

	return &config, nil
}

func (p *Parser) SaveUserConfig(config *models.UserConfig, filePath string) error {
	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	if err := os.WriteFile(filePath, data, 0644); err != nil {
		return fmt.Errorf("failed to write config file: %w", err)
	}

	return nil
}

// GenerateConfFile 根据用户配置生成DHF conf文件 - 通用版本
func (p *Parser) GenerateConfFile(config *models.UserConfig, filePath string) error {
	var confLines []string
	
	// 文件头部注释
	confLines = append(confLines, "#")
	confLines = append(confLines, "#  @file    dhf_config.conf")
	confLines = append(confLines, "#  @brief   DHF Configuration File")
	confLines = append(confLines, "#  @note    Generated by DHF Configuration Manager")
	confLines = append(confLines, "#           Created by Felix")
	confLines = append(confLines, fmt.Sprintf("#           Generated on %s", time.Now().Format("2006-01-02 15:04:05")))
	confLines = append(confLines, "#")
	confLines = append(confLines, "")
	confLines = append(confLines, "#***************************************************************************")
	confLines = append(confLines, "#                       DHF Configuration Settings")
	confLines = append(confLines, "#***************************************************************************")
	confLines = append(confLines, "")

	// 按section分组处理配置
	var allKeys []string
	for key := range config.Values {
		allKeys = append(allKeys, key)
	}
	sort.Strings(allKeys)

	currentSection := ""
	for _, key := range allKeys {
		value := config.Values[key]
		
		// 解析key路径，例如 "basic.ic_model" 或 "key_actions.call_scenario.active_click"
		parts := strings.Split(key, ".")
		if len(parts) >= 1 {
			var sectionKey, confKey string
			
			if len(parts) == 1 {
				// 一级配置：key -> _KEY
				sectionKey = "GENERAL"
				confKey = fmt.Sprintf("_%s", strings.ToUpper(parts[0]))
			} else if len(parts) == 2 {
				// 二级配置：section.field -> _SECTION_FIELD  
				sectionKey = strings.ToUpper(parts[0])
				confKey = fmt.Sprintf("_%s_%s", strings.ToUpper(parts[0]), strings.ToUpper(parts[1]))
			} else {
				// 三级或更深配置：section.group.field -> _SECTION_GROUP_FIELD
				sectionKey = strings.ToUpper(parts[0])
				// 将所有中间部分和最后部分用下划线连接
				fieldParts := make([]string, len(parts))
				for i, part := range parts {
					fieldParts[i] = strings.ToUpper(part)
				}
				confKey = "_" + strings.Join(fieldParts, "_")
			}
			
			// 如果是新的section，添加section注释
			if currentSection != sectionKey {
				if currentSection != "" {
					confLines = append(confLines, "")
				}
				
				// 生成section注释
				sectionName := p.getSectionName(strings.ToLower(parts[0]))
				confLines = append(confLines, fmt.Sprintf("# %s", sectionName))
				confLines = append(confLines, "#" + strings.Repeat("-", len(sectionName)+2))
				currentSection = sectionKey
			}
			
			// 生成配置行
			confLines = append(confLines, fmt.Sprintf("%s=%v", confKey, value))
		}
	}
	
	// 文件尾部
	confLines = append(confLines, "")
	confLines = append(confLines, "#***************************************************************************")
	confLines = append(confLines, "#                       End of Configuration")
	confLines = append(confLines, "#***************************************************************************")

	// 写入文件
	content := strings.Join(confLines, "\n")
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write conf file: %w", err)
	}

	return nil
}

// getSectionName 获取section的显示名称
func (p *Parser) getSectionName(sectionKey string) string {
	nameMap := map[string]string{
		"basic":      "基础配置 (Basic Configuration)",
		"key_actions": "按键配置 (Key Actions)",
		"led_config": "LED配置 (LED Configuration)",
		"factory":    "工厂设置 (Factory Settings)",
		"advanced":   "高级设置 (Advanced Settings)",
		"general":    "通用配置 (General Configuration)",
	}
	
	if name, exists := nameMap[sectionKey]; exists {
		return name
	}
	return fmt.Sprintf("%s配置 (%s Configuration)", strings.Title(sectionKey), strings.Title(sectionKey))
}

// SaveConfigWithConf 保存YAML配置并同时生成conf文件
func (p *Parser) SaveConfigWithConf(config *models.UserConfig, yamlPath string) error {
	// 保存YAML文件
	if err := p.SaveUserConfig(config, yamlPath); err != nil {
		return fmt.Errorf("failed to save YAML config: %w", err)
	}

	// 生成对应的conf文件路径（同目录，扩展名改为.conf）
	dir := filepath.Dir(yamlPath)
	base := strings.TrimSuffix(filepath.Base(yamlPath), filepath.Ext(yamlPath))
	confPath := filepath.Join(dir, base+".conf")

	// 生成conf文件
	if err := p.GenerateConfFile(config, confPath); err != nil {
		return fmt.Errorf("failed to generate conf file: %w", err)
	}

	return nil
}